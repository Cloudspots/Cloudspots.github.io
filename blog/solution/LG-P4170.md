# 洛谷 P4170 题解

找性质，然后 dp。最近在练习找性质的题目。

我们有关键结论：存在最优解满足任何相交的两次涂色都是包含关系且端点各不相同。

> 证明：
>
> 原命题相当于不会出现两次涂色 $[a,b]$ 和 $[c,d]$，有 $a \le c \le b \le d$。
>
> 如果存在最优解满足有这样的涂色，那么选取任意一个没有任何一个时间介于这两者之间的波及到了 $[a,d]$ 中格子的两个涂色（必然存在。任意选取两个满足的 $[a,b]$ 和 $[c,d]$，如果中间有则分情况：如果是任何一个区间包含了的，则其实没用，还浪费了一次，不是最优解。否则，它和 $[a,b]$ 或 $[c,d]$ 中的一个也必然满足上述关系，并且时间间隔更短，那么选择这两个并重复上面操作，而每次时间间隔都会减小并且最小为 $1$，所以只需要进行有限次操作就能找到），将时间更前的那一个不涂 $[b,c]$ 这一段，结果相同但是少了一个这样的涂色组。而这样的涂色组只有有限个，每次少一个最后总会变成 $0$，找到了一个代价一样的解但是没有出现这样的涂色组，所以证毕。
>

这样我们就可以 dp 了。区间 dp，那么转移就是：

1. 有一个端点不同的子区间，后选：则一种显然的想法是 $f_{i+1,j-1}$ 转移到 $f_{i,j}$，但是必须满足 $s_i=s_j$。这样是错的，因为还有最外面一次涂色。那么一种显然的想法就是 $f_{i+1,j-1}+1$。这样也是错的，因为可能有类似 `AABAA` 的东西卡你。正确的方法是 $f_{i+1,j}$，因为我们可以同时把 $i$ 和 $j$ 涂掉。
2. 分成两种涂色：则用 $f_{i,k}+f_{k+1,j}$ 转移 $f_{i,j}$。

这样我们就得到了时间复杂度 $\mathcal O(n^3)$ 的做法。

code：

```cpp
#include <cstdio>

using namespace std;

int f[55][55];
char s[55];

int main()
{
    int n = 0;
    while((s[++n] = getchar()) >= 'A' && s[n] <= 'Z');
    n--;
    for(int l=1;l<=n;l++)
    {
        for(int i=1;i<=n-l+1;i++)
        {
            int j = i + l - 1;
            if(l == 1) f[i][j] = 1;
            else if(l == 2) f[i][j] = 1 + int(s[i] != s[j]);
            else
            {
                f[i][j] = s[i] == s[j] ? f[i][j-1] : 114514;
                for(int k=i;k<j;k++)
                {
                    if(f[i][k] + f[k+1][j] < f[i][j]) f[i][j] = f[i][k] + f[k+1][j];
                }
            }
            // printf("f[%d][%d] = %d\n", i, j, f[i][j]);
        }
    }
    printf("%d\n", f[1][n]);
    return 0;
}
```
