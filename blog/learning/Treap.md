# Treap 学习笔记

本文章大部分图片选自 Treap 的 [OI-wiki 页面](https://oi-wiki.org/ds/treap/)，感谢 OI-wiki。

## 数据结构简介

> 坏了我每次 Treap 都打成 Tr\*\*p（
>
> Treap = **Tre**e + H**eap**。

众所周知，二叉搜索树（BST）是一个功能更多的东西，但是对于如何平衡……没那么简单。二叉搜索树的很多操作时间复杂度都是 $\mathcal O(h)$ 的，其中 $h$ 是树高。如果树非常不平衡（如退化成链），则时间复杂度也会退化。

而如何解决二叉搜索树不平衡的问题的一种方法就是和二叉堆（大根堆或小根堆均可）结合。

堆+二叉搜索树，额……可以一定程度上（在期望上 $^1$）解决这个问题。

Treap 的每个节点除了需要记录的权值 $v$ 之外，还有一个优先级 $p$（显然堆和二叉搜索树不能直接并存）。在 $v$ 看来，整棵树是二叉搜索树。在 $p$ 看来是堆，小根堆或大根堆均可。

一个 Treap 的例子（白色代表 $p$，黑色代表 $v$）：

![Treap 例 --来自 OI-wiki](https://oi-wiki.org/ds/images/treap-treap-example.svg)

而 Treap 是如何解决二叉搜索树不平衡问题的呢？答案是随机赋予权值 $p$，增加了 $p$ 的要求之后 BST 反而变得平衡了。

### 如何维护树

我们确实还是按照权值 $v$ 来构树的，我们操作完还要进行调整。

调整称为旋转（rotate），又分为左旋和右旋。

通俗来讲，对于一个节点进行左旋，实际上就是把它的右子节点“提到上面来”。实际上有略微的不同（提完之前的那个右子节点的左子树会变成根节点的右子树，这个过程还是挺形象的）。右旋类似，可以参考下图。

![左旋与右旋 --来自 OI-wiki](https://oi-wiki.org/ds/images/treap-rotate.svg)

为什么要进行左旋与右旋？我们发现，旋转并不会

## 注释

${}^0$: 本地 VSCode 不支持 `[^xxx]` 语法注释，故使用 $\KaTeX$ 代替。

${}^1$：大概率能够解决，就像随机选择哨兵的快速排序一样。
