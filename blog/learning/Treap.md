# Treap 学习笔记

本文章大部分图片选自 Treap 的 [OI-wiki 页面](https://oi-wiki.org/ds/treap/)，感谢 OI-wiki。

## 数据结构简介

> 坏了我每次 Treap 都打成 Tr\*\*p（
>
> Treap = **Tre**e + H**eap**。

众所周知，二叉搜索树（BST，我写过一篇讲这个的文章可以自行搜索，等我把网站搭好会放链接）是一个功能更多的东西，但是对于如何平衡……没那么简单。二叉搜索树的很多操作时间复杂度都是 $\mathcal O(h)$ 的，其中 $h$ 是树高。如果树非常不平衡（如退化成链），则时间复杂度也会退化。

而如何解决二叉搜索树不平衡的问题的一种方法就是和二叉堆（大根堆或小根堆均可）结合。

堆+二叉搜索树，额……可以一定程度上（在期望上 $^1$）解决这个问题。

Treap 的每个节点除了需要记录的权值 $v$ 之外，还有一个优先级 $p$（显然堆和二叉搜索树不能直接并存）。在 $v$ 看来，整棵树是二叉搜索树。在 $p$ 看来是堆，小根堆或大根堆均可。

一个 Treap 的例子（白色代表 $p$，黑色代表 $v$）：

![Treap 例 --来自 OI-wiki](https://oi-wiki.org/ds/images/treap-treap-example.svg)

而 Treap 是如何解决二叉搜索树不平衡问题的呢？答案是随机赋予权值 $p$，增加了 $p$ 的要求之后 BST 反而变得平衡了。

### 如何维护树

我们确实还是按照权值 $v$ 来构树的，我们操作完还要进行调整，因为可能违反二叉堆性质。

调整称为旋转（rotate），又分为左旋和右旋。

通俗来讲，对于一个节点进行左旋，实际上就是把它的右子节点“提到上面来”。实际上有略微的不同（提完之前的那个右子节点的左子树会变成根节点的右子树，这个过程还是挺形象的）。右旋类似，可以参考下图。

![左旋与右旋 --来自 OI-wiki](https://oi-wiki.org/ds/images/treap-rotate.svg)

为什么要进行左旋与右旋？我们发现，旋转并不会违反二叉搜索树性质，但是会略微改变堆性质。如下图，$\alpha$ 和 $\gamma$ 的大小关系颠倒，除此之外没有区别：

![左旋与右旋 --自行绘制](https://s21.ax1x.com/2025/05/07/pELZsk8.png)

这个可以实现什么功能呢？我们思考一下二叉堆是如何维护的。其中用到了一个操作“交换两个元素”，实际上就是为了修复某一处堆性质而尽量不违反其它地方的堆性质而使用的操作。这里的旋转和交换操作本质相同，实际上也是可以相互替换的。

我们使用旋转代替二叉堆的交换操作即可。

## 时间复杂度

正确性非常显然不证明了。

较难分析（因为涉及到随机算法）。显然还都是 $\mathcal O(h)$ 的，$h$ 最大也是 $\Theta O(n)$ 级别的，但是期望？

关于时间复杂度，我不会证明。我的数学很烂。可以看 [OI-wiki](https://oi.wiki/ds/treap/#treap-%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E8%AF%81%E6%98%8E)。

## 注释

${}^0$: 本地 VSCode 不支持 `[^xxx]` 语法注释，故使用 $\KaTeX$ 代替。

${}^1$：大概率能够解决，就像随机选择哨兵的快速排序一样。
